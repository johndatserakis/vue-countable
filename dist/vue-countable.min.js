var VueCountable = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var Countable = createCommonjsModule(function (module, exports) {
	(function (global) {

	  /**
	   * @private
	   *
	   * `liveElements` holds all elements that have the live-counting
	   * functionality bound to them.
	   */

	  var liveElements = [];
	  var each = Array.prototype.forEach;

	  /**
	   * `ucs2decode` function from the punycode.js library.
	   *
	   * Creates an array containing the decimal code points of each Unicode
	   * character in the string. While JavaScript uses UCS-2 internally, this
	   * function will convert a pair of surrogate halves (each of which UCS-2
	   * exposes as separate characters) into a single code point, matching
	   * UTF-16.
	   *
	   * @see     <http://goo.gl/8M09r>
	   * @see     <http://goo.gl/u4UUC>
	   *
	   * @param   {String}  string   The Unicode input string (UCS-2).
	   *
	   * @return  {Array}   The new array of code points.
	   */

	  function decode (string) {
	    var output = [];
	  	var counter = 0;
	  	var length = string.length;

	  	while (counter < length) {
	  		var value = string.charCodeAt(counter++);

	  		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {

	  			// It's a high surrogate, and there is a next character.

	  			var extra = string.charCodeAt(counter++);

	  			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	  				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	  			} else {

	  				// It's an unmatched surrogate; only append this code unit, in case the
	  				// next code unit is the high surrogate of a surrogate pair.

	  				output.push(value);
	  				counter--;
	  			}
	  		} else {
	  			output.push(value);
	  		}
	  	}

	  	return output
	  }

	  /**
	   * `validateArguments` validates the arguments given to each function call.
	   * Errors are logged to the console as warnings, but Countable fails
	   * silently.
	   *
	   * @private
	   *
	   * @param   {Nodes|String}  targets   A (collection of) element(s) or a single
		 *                                    string to validate.
	   *
	   * @param   {Function}      callback  The callback function to validate.
	   *
	   * @return  {Boolean}       Returns whether all arguments are vaild.
	   */

	  function validateArguments (targets, callback) {
	    var nodes = Object.prototype.toString.call(targets);
	    var targetsValid = typeof targets === 'string' || ((nodes === '[object NodeList]' || nodes === '[object HTMLCollection]') || targets.nodeType === 1);
	    var callbackValid = typeof callback === 'function';

	    if (!targetsValid) { console.error('Countable: Not a valid target'); }
	    if (!callbackValid) { console.error('Countable: Not a valid callback function'); }

	    return targetsValid && callbackValid
	  }

	  /**
	   * `count` trims an element's value, optionally strips HTML tags and counts
	   * paragraphs, sentences, words, characters and characters plus spaces.
	   *
	   * @private
	   *
	   * @param   {Node|String}  target   The target for the count.
	   *
	   * @param   {Object}   	   options  The options to use for the counting.
	   *
	   * @return  {Object}       The object containing the number of paragraphs,
	   *                         sentences, words, characters and characters
		 *                         plus spaces.
	   */

	  function count (target, options) {
	    var original = '' + (typeof target === 'string' ? target : ('value' in target ? target.value : target.textContent));
	    options = options || {};

	    /**
	     * The initial implementation to allow for HTML tags stripping was created
	     * @craniumslows while the current one was created by @Rob--W.
	     *
	     * @see <http://goo.gl/Exmlr>
	     * @see <http://goo.gl/gFQQh>
	     */

	    if (options.stripTags) { original = original.replace(/<\/?[a-z][^>]*>/gi, ''); }

	    if (options.ignore) {
	        each.call(options.ignore, function (i) {
	            original = original.replace(i, '');
	        });
	    }

	    var trimmed = original.trim();

	    /**
	     * Most of the performance improvements are based on the works of @epmatsw.
	     *
	     * @see <http://goo.gl/SWOLB>
	     */

	    return {
	      paragraphs: trimmed ? (trimmed.match(options.hardReturns ? /\n{2,}/g : /\n+/g) || []).length + 1 : 0,
	      sentences: trimmed ? (trimmed.match(/[.?!…]+./g) || []).length + 1 : 0,
	      words: trimmed ? (trimmed.replace(/['";:,.?¿\-!¡]+/g, '').match(/\S+/g) || []).length : 0,
	      characters: trimmed ? decode(trimmed.replace(/\s/g, '')).length : 0,
	      all: decode(original).length
	    }
	  }

	  /**
	   * This is the main object that will later be exposed to other scripts. It
	   * holds all the public methods that can be used to enable the Countable
	   * functionality.
	   *
	   * Some methods accept an optional options parameter. This includes the
	   * following options.
	   *
	   * {Boolean}      hardReturns  Use two returns to seperate a paragraph
	   *                             instead of one. (default: false)
	   * {Boolean}      stripTags    Strip HTML tags before counting the values.
	   *                             (default: false)
	   * {Array<Char>}  ignore       A list of characters that should be removed
	   *                             ignored when calculating the counters.
	   *                             (default: )
	   */

	  var Countable = {

	    /**
	     * The `on` method binds the counting handler to all given elements. The
	     * event is either `oninput` or `onkeydown`, based on the capabilities of
	     * the browser.
	     *
	     * @param   {Nodes}     elements   All elements that should receive the
	     *                                 Countable functionality.
	     *
	     * @param   {Function}  callback   The callback to fire whenever the
	     *                                 element's value changes. The callback is
	     *                                 called with the relevant element bound
	     *                                 to `this` and the counted values as the
	     *                                 single parameter.
	     *
	     * @param   {Object}    [options]  An object to modify Countable's
	     *                                 behaviour.
	     *
	     * @return  {Object}    Returns the Countable object to allow for chaining.
	     */

	    on: function (elements, callback, options) {
	      if (!validateArguments(elements, callback)) { return }

	      if (!Array.isArray(elements)) {
	          elements = [ elements ];
	      }

	      each.call(elements, function (e) {
	          var handler = function () {
	            callback.call(e, count(e, options));
	          };

	          liveElements.push({ element: e, handler: handler });

	          handler();

	          e.addEventListener('input', handler);
	      });

	      return this
	    },

	    /**
	     * The `off` method removes the Countable functionality from all given
	     * elements.
	     *
	     * @param   {Nodes}   elements  All elements whose Countable functionality
	     *                              should be unbound.
	     *
	     * @return  {Object}  Returns the Countable object to allow for chaining.
	     */

	    off: function (elements) {
	      if (!validateArguments(elements, function () {})) { return }

	      if (!Array.isArray(elements)) {
	          elements = [ elements ];
	      }

	      liveElements.filter(function (e) {
	          return elements.indexOf(e.element) !== -1
	      }).forEach(function (e) {
	          e.element.removeEventListener('input', e.handler);
	      });

	      liveElements = liveElements.filter(function (e) {
	          return elements.indexOf(e.element) === -1
	      });

	      return this
	    },

	    /**
	     * The `count` method works mostly like the `live` method, but no events are
	     * bound, the functionality is only executed once.
	     *
	     * @param   {Nodes|String}  targets   All elements that should be counted.
	     *
	     * @param   {Function}      callback   The callback to fire whenever the
	     *                                     element's value changes. The callback
			 *                                     is called with the relevant element
			 *                                     bound to `this` and the counted values
			 *                                     as the single parameter.
	     *
	     * @param   {Object}        [options]  An object to modify Countable's
	     *                                     behaviour.
	     *
	     * @return  {Object}    Returns the Countable object to allow for chaining.
	     */

	    count: function (targets, callback, options) {
	      if (!validateArguments(targets, callback)) { return }

	      if (!Array.isArray(targets)) {
	          targets = [ targets ];
	      }

	      each.call(targets, function (e) {
	          callback.call(e, count(e, options));
	      });

	      return this
	    },

	    /**
	     * The `enabled` method checks if the live-counting functionality is bound
	     * to an element.
	     *
	     * @param   {Node}     element  All elements that should be checked for the
	     *                              Countable functionality.
	     *
	     * @return  {Boolean}  A boolean value representing whether Countable
	     *                     functionality is bound to all given elements.
	     */

	    enabled: function (elements) {
	      if (elements.length === undefined) {
	        elements = [ elements ];
	      }

	      return liveElements.filter(function (e) {
	          return elements.indexOf(e.element) !== -1
	      }).length === elements.length
	    }

	  };

	  /**
	   * Expose Countable depending on the module system used across the
	   * application. (Node / CommonJS, AMD, global)
	   */

	  {
	    module.exports = Countable;
	  }
	}(commonjsGlobal));
	});

	//

	var script = {
	    name: 'VueCountable',
	    props: {
	        text: {
	            type: String,
	            required: true
	        },
	        elementId: {
	            type: String,
	            required: true
	        },
	        hardReturns: {
	            type: Boolean,
	            required: false,
	            default: false
	        },
	        stripTags: {
	            type: Boolean,
	            required: false,
	            default: false
	        },
	        ignore: {
	            type: Array,
	            required: false,
	            default: function () { return []; }
	        }
	    },
	    data: function data () {
	        return {
	            countable: null
	        }
	    },
	    computed: {
	        options: function options () {
	            return {
	                hardReturns: this.hardReturns,
	                stripTags: this.stripTags,
	                ignore: this.ignore
	            }
	        }
	    },
	    watch: {
	        text: {
	            handler: function (value) {
	                // Everytime this.text changes we'll update our live count
	                this.init();
	            }
	        }
	    },
	    methods: {
	        init: function init () {
	            var this$1 = this;

	            // Set our countable instance
	            this.countable = Countable;

	            this.$nextTick(function () {
	                this$1.countable.count(this$1.text, function (counter) {
	                    this$1.$emit('change', counter);
	                }, this$1.options);
	            });
	        }
	    },
	    mounted: function mounted () {
	        // The init function is important because we want to provide counts not
	        // only during changes, but also on initialization.
	        this.init();
	    }
	}

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	/* server only */
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  } // Vue.extend constructor export interop.


	  var options = typeof script === 'function' ? script.options : script; // render functions

	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true; // functional template

	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  } // scopedId


	  if (scopeId) {
	    options._scopeId = scopeId;
	  }

	  var hook;

	  if (moduleIdentifier) {
	    // server build
	    hook = function hook(context) {
	      // 2.3 injection
	      context = context || // cached call
	      this.$vnode && this.$vnode.ssrContext || // stateful
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
	      // 2.2 with runInNewContext: true

	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      } // inject component styles


	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      } // register component module identifier for async chunk inference


	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    }; // used by ssr in case component is cached and beforeCreate
	    // never gets called


	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }

	  if (hook) {
	    if (options.functional) {
	      // register for functional component in vue file
	      var originalRender = options.render;

	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      // inject component registration as beforeCreate hook
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }

	  return script;
	}

	var normalizeComponent_1 = normalizeComponent;

	var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
	function createInjector(context) {
	  return function (id, style) {
	    return addStyle(id, style);
	  };
	}
	var HEAD = document.head || document.getElementsByTagName('head')[0];
	var styles = {};

	function addStyle(id, css) {
	  var group = isOldIE ? css.media || 'default' : id;
	  var style = styles[group] || (styles[group] = {
	    ids: new Set(),
	    styles: []
	  });

	  if (!style.ids.has(id)) {
	    style.ids.add(id);
	    var code = css.source;

	    if (css.map) {
	      // https://developer.chrome.com/devtools/docs/javascript-debugging
	      // this makes source maps inside style tags work properly in Chrome
	      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

	      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
	    }

	    if (!style.element) {
	      style.element = document.createElement('style');
	      style.element.type = 'text/css';
	      if (css.media) { style.element.setAttribute('media', css.media); }
	      HEAD.appendChild(style.element);
	    }

	    if ('styleSheet' in style.element) {
	      style.styles.push(code);
	      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
	    } else {
	      var index = style.ids.size - 1;
	      var textNode = document.createTextNode(code);
	      var nodes = style.element.childNodes;
	      if (nodes[index]) { style.element.removeChild(nodes[index]); }
	      if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }else { style.element.appendChild(textNode); }
	    }
	  }
	}

	var browser = createInjector;

	/* script */
	var __vue_script__ = script;

	/* template */
	var __vue_render__ = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div")
	};
	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;

	  /* style */
	  var __vue_inject_styles__ = function (inject) {
	    if (!inject) { return }
	    inject("data-v-12d8198d_0", { source: "\n/*# sourceMappingURL=vue-countable.vue.map */", map: {"version":3,"sources":["vue-countable.vue"],"names":[],"mappings":";AACA,4CAA4C","file":"vue-countable.vue"}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__ = "data-v-12d8198d";
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* style inject SSR */
	  

	  
	  var component = normalizeComponent_1(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    browser,
	    undefined
	  )

	// Import vue component

	// install function executed by Vue.use()
	function install(Vue) {
		if (install.installed) { return; }
		install.installed = true;
		Vue.component('VueCountable', component);
	}

	// Create module definition for Vue.use()
	var plugin = {
		install: install,
	};

	// To auto-install when vue is found
	var GlobalVue = null;
	if (typeof window !== 'undefined') {
		GlobalVue = window.Vue;
	} else if (typeof global !== 'undefined') {
		GlobalVue = global.Vue;
	}
	if (GlobalVue) {
		GlobalVue.use(plugin);
	}

	// It's possible to expose named exports when writing components that can
	// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
	// export const RollupDemoDirective = component;

	exports.install = install;
	exports.default = component;

	return exports;

}({}));
